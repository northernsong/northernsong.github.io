{"pages":[],"posts":[{"title":"macbook pro 2017 键盘映射","text":"背景 我以前的键盘是poker3，61键，没有方向键，没有fn区域。所以有很多习惯是跟普通键盘不同的。 之前的一些习惯 我把CaspLock切换为fn，使用fn+a/s/d/w控制方向。目的呢就是为了右手使用键盘的时候，有些左手来控制方向。 我还习惯用左手来控制下pageUp,pageDown,Home,End等功能，也通过fn+shift/ctrl/q/e来实现了。 我的CaspLock=fn,fn+tab = CaspLock 目前的困扰目前设备： MacBook Pro 2017 圣手2代蓝牙键盘（87键的那种） 外接显示器 不习惯右手去按方向键，经常按错键位，例如我想←，我按的是CaspLock + a！ 解决 我个人实在懒得去学习那些不同应用里的快捷键，不能完全扔掉鼠标，那么我还是想用左手来操作的话… Karabiner-Elements这个软件好像改过名字，这个版本是对应macOs10.13的下载链接 https://pqrs.org/osx/karabiner/ 官网 https://github.com/tekezo/Karabiner-Elements 源码","link":"/2018-01/macbook-pro-2017-mapper.html"},{"title":"elasticsearch删除索引后再新建时踩得坑","text":"这个正在维护的项目是从外包手里接来的，所以里面有些技术并不是很熟练;测试环境的ES里的数据有点乱,决定清空所有索引再重新拉取数据试试，问题来了，按照原先的方式搜索不到数据了！！！但通过head插件看还有的！看了官方文档发现，我们没有重新建立映射 事件的过程 所有操作都在elasticsearch插件head里 1. 清空所有索引这个删除操作和linux rm -rf / 一样简单 12DELETE\\* 就是酱紫，点击提交，就全部删除了。你可以刷新下页面，看看。 2. 导入数据我们的数据是怎么到ES的在项目里，我们查询ES数据时是通过spring data jpa,但插入并不是，是一个定时任务拉取第三方平台，数据量比较大，集成了kafka，再由logstash发送到ES。kafka是直接发送的json格式的字符串，logstash里配置了动态模板。可以说是跟默认的差不多。 问题出现了可以说每个发送到ES里的对象（应该叫文档）都有非常多的字段，里面大部分都是不需要分词的，但动态模板不会判断，所以到ES里数据都被分词了！然后我们使用聚合查询部分代码是这样的： 12TermsBuilder provinceTermsBuilder = AggregationBuilders.terms(\"provinceAgg\").field(\"provinceCode.raw\");TermsBuilder cityTermsBuilder = AggregationBuilders.terms(\"cityAgg\").field(\"cityCode.raw\"); 嗯，我们查不到任何数据。看看.raw,官方解释大概总结下，就是同一个字段，多一个映射的方式。但这个映射我们没有设置过！我们没有provinceCode.raw和cityCode.raw字段,所以通过这两个字段来查询根本没有任何数据 这两个字段代表的省市的代码，例如31代表上海。这个是不需要分词的。 3. 研究索引问题原因找到了。研究怎么去做这个映射，官方文档看完，想起，外包交接时给过一个映射的json格式的文件，查看一下，应该就是这些字段的映射，但可能是版本或文档更新的问题，直接执行后，并未起作用，按照文档中官方文档做了下修改，OK大概流程是 再次删除所有索引 新建索引并设置映射 在解决索引问题时，还出现了查询数据时找不到索引的问题。发现spring data jpa里配置的ES索引名和实际索引不同。Google一下，果然ES里还有别名这一个概念，引用官网的话： 即使你认为现在的索引设计已经很完美了，在生产环境中，还是有可能需要做一些修改的。做好准备：在你的应用中使用别名而不是索引名。然后你就可以在任何时候重建索引。别名的开销很小，应该广泛使用 4. 还有初始值这样的操作！依然没有数据！在交接时加入了一个新功能，因此新加了一个字段。不过这个字段有默认值！所以查询这个字段时没有数据。默认值设置： 123METHOD: POSTURL: /{索引}/{字段}/_update_by_query{\"script\":{\"inline\":\"ctx._source.{字段}=0\"}} 注意要用post方法，一不小心用了put直接就是新建一个{字段}类型了。然后查询这个字段时又是各种问题。无奈删之！ 总结使用ES开发,需要注意备份配置： 索引的映射 索引别名 调试开发时注意http方法。一不小心用了DELETE那就是删除喽","link":"/2018-03/elasticsearch-delete-pit-0.html"},{"title":"spring boot eureka的认识","text":"spring cloud的生态很舒服的，eureka作为注册中心很重要。以下记录使用时的一点感受 什么是 eureka？它是一个服务中心 也叫注册中心，顾名思义，就是各个微服务（rpc接口）注册，发现管理的地方。类似的有dubbo，dubbo admin。 其最直观或者说最基本的功能就是注册服务。假设你有n多个项目，互相调用接口，并都是集群部署的情况下，那么在没有注册中心的情况下该如何去调用远程接口，其中一个项目的ip或端口改动后，使用其接口的项目也要对应改变！何其麻烦而且容易出错（之前我任职的一家公司有一段时间是用域名解决这个问题）。通过注册中心来调度，只需要关注注册中心的地址即可。 由于各种服务都注册到了服务中心，就有了去做很多高级功能条件。比如几台服务提供相同服务来做均衡负载；监控服务器调用成功率来做熔断，移除服务列表中的故障点；监控服务调用时间来对不同的服务器设置不同的权重等等。 ——引用博客 [《纯洁的微笑》](http://www.ityouknow.com/springcloud/2017/05/10/springcloud-eureka.html) 一些经验集群/单机部署对于刚接触的人，对配置不熟悉的话，单机还是集群部署，都需要去修改里面的配置，例如什么自我注册之类。集群的时候，只有全部启动才不会报错，不熟悉的还会以为没起来呢。集群的改单机的，也同样需要改一下配置，不是简单的删去其他注册中心的url那么简单。 对于开发者来说，本地开发测试时，完全可以用docker来在本地部署，贼方便。 为啥公司开发环境有了eureka了，但还要在本地部署呢？ 很多公司，哪怕是开发环境都跟开发者本地的机器都是不同网段的，这个可以通过代理解决，但是！注册进来的其他服务跟你的网络还是不同的，这个时候配置的hosts可以派上用处了，但服务太多的话，真的有些麻烦！ hosts的配置eureka像注册中心注册时，默认是使用hostname的，刚开始我们接入时，在集群的服务器上每个服务器上都在/etc/hosts里配置了ip和hostname（幸好我们服务器并不多，只有3，40台，然后去改配置的人不是我）。 开始还好，后来弄成K8S了，这改起来就麻烦了。我们索性把服务注册时bootstrap.yml配置上注册时使用本机ip！再也不用麻烦了。 本地开发时，怎么自动连入k8s里的环境呢？？？网上有些办法的，但目前我们公司网络管控太严格，没有实践 eureka的监控页面发生一些莫名其妙的问题的时候，看看eureka的监控页面，看看是不是有什么不该注册进来的服务注册进来了。看一下，问题就能知道出在哪里了，非常快的，哪怕问题不是出在这里，也能快速的排查掉一个问题可能出现的点！ 日志里接口的地址如果打印了feign的日志话，会发现里面接口的地址是 http://服务名/xxx,而不是真实的地址。 这个因为feign里是Target ，这个接口可以控制请求的真实URL。 有兴趣的同学可以看 (spring boot 2.0跟之前的路径有所不同，可以直接搜类名) 1org.springframework.cloud.openfeign.FeignClientFactoryBean#getTarget feign里封装了ribbon，ribbon实现负载均衡的功能，也就是服务名转成真实URL的方法。不过这里的源码我就没有深入的探索了，这里会有一些调用eureka查询路由的一些功能吧。 fallback的实现和全日志输出当接口发生异常时需要配置返回的东西，我们往往是通过实现feign接口的方法的形式来完成的，我建议使用fallbackFactory工厂模式，这样你能根据错误码来定制更多的功能，简单的控制日志输出 PS：如果通过配置等级FULL来打印所有日志，里面会包含具体的网络通信的日志，但是！太多了，并且分行打印的，如果你有日志可视化工具也还好，只是通过 grep xxx xxx.log -C/-A/-B 这样的话，看的眼花！ 熔断和降级有人问我eureka如何熔断的，我回顾了下，这个可能跟eureka没有太大的关系，是由Hystrix来完成的，配置Hystrix后，服务调用者有自己的线程池，如果请求量太多，或者占用时间太长（区别请求时间，一个意思，不过请求超时一般是指http的时间），或者请求失败，就会触发Fallback处理，能够快速的返回一个结果，避免服务雪崩 服务雪崩，不管是微服务，还是传统的服务，都有可能发生的。我就发生过因资源用尽导致服务宕机 参考eureka源码github地址：https://github.com/Netflix/eureka文档：https://cloud.spring.io/spring-cloud-static/spring-cloud-netflix/2.2.2.RELEASE/reference/html/ 部署指导：https://spring.io/guides/gs/service-registration-and-discovery/spring cloud 文档： https://spring.io/projects/spring-cloud","link":"/2017-12/spring-boot-eureka-0.html"},{"title":"Hello World","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","link":"/2018-01/hello-hexo.html"},{"title":"hexo 通过git服务器部署到vps","text":"通常为了节约成本都会把Hexo部署至github上，但那个上面有时候访问确实太慢了，正好手头上有服务器，那么完全可以部署在自己的服务器上。 先说我自己的方法 我有自己部署好的jenkins，如果有阿里云的话，好像也有免费的类似jenkins的部署流程的 git远程仓库使用gitee或github，在webhook里添加jenkins的部署项目的密钥 额，这个应该跟2换下位置。在jenkins里新建部署任务，当有webhook的push时触发自动构建，任务内容就是git pull 用nginx配置能够访问git pull来的静态资源的目录 完工 网上的方式网上的，一般都是自己搭建个git服务器版 大致步骤如下： 服务器安装 git 添加git用户 新建仓库 把仓库目录权限给 git checkout的目录权限给git hexo 安装 git-deploy 插件 改配置 deploy 下试试 参考：http://www.swiftyper.com/2016/04/17/deploy-hexo-with-git-hook/https://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000/00137583770360579bc4b458f044ce7afed3df579123eca000http://www.ruanyifeng.com/blog/2011/12/ssh_remote_login.htmlhttps://segmentfault.com/a/1190000005349818","link":"/2018-01/hexo-git-deploy-vps-0.html"},{"title":"java8的时间和`Date`的对比","text":"java8提供了新的时间接口。相对Date,Calendar,个人感觉最大的好处是对时间操作的学习成本很低，比Calendar低，比更Date低。 1. LocalDate,LocalTime,LocalDateTimeLocalDate 代表日期，LocalTime表示时刻，类似11:23这样的时刻。LocalDateTime就是前面2个的结合,这个可以从java.time.LocalDateTime#toString的代码看出一二： 1234@Overridepublic String toString() { return date.toString() + 'T' + time.toString();} date,time 在java.time.LocalDateTime中 12345678/** * The date part. */private final LocalDate date;/** * The time part. */private final LocalTime time; 实际使用中，计算日期就用LocalDate,计算日期加时刻用LocalDateTime，如果只有时刻就是LocalTime（感觉在说废话）这三个的用法基本上一样，通过方法名就知道用法那种 1.1 获取当前时间的对象12LocalDateTime localDateTime = LocalDateTime.now();Date date = new Date(); localDateTime相比Date更像是一个工具类，就是为了时间操作使用。其构造方法是私有的。 1.2 从字符串中解析字符串 2019-01-11 解析成时间对象 12345678910String str = &quot;2019-01-11&quot;;DateTimeFormatter formatter = DateTimeFormatter.ofPattern(&quot;yyyy-MM-dd&quot;);LocalDate localDate = LocalDate.parse(str, formatter);SimpleDateFormat simpleDateFormat = new SimpleDateFormat(&quot;yyyy-MM-dd&quot;);try { Date date = simpleDateFormat.parse(str);} catch (ParseException e) { e.printStackTrace();} DateTimeFormatter的包路径是java.time.format和LocalDate一样在java.time下面，而SimpleDateFormat和Date是不同的。所以当判断引入路径的时候更容易判断。当解析失败的时候，两个异常的抛出不一样，DateTimeFormatter抛出的是DateTimeParseException,继承自RuntimeException,而ParseException明显继承的是Exception。个人感觉这个思路是，前者如果抛出异常那就是编程上错误，而后者则是的程序代码的不稳定性。我更倾向于第一种的异常设计，应该加强对入参的检测判断，而不是通过捕获异常去处理入参的错误。（类似NumberFormatException） 1.3 LocalDate比Date更强的初始化时间Date 设置某个日期，基本上3个方式，时间戳/Calendar/字符串解析。相对的LocalDate就简单了很多 1LocalDate.of(2019,1,12); 其他的也一样 1.4 时间戳的转换时间戳和时区关系的参考时间转换代码参考 在这里时间戳的转换不如Date直接。主要因为LocalDate本身是没有时区的。 时间戳传LocalDateTime 123long timestamp = System.currentTimeMillis();Instant instant = Instant.ofEpochMilli(timestamp);LocalDateTime.ofInstant(instant, ZoneId.systemDefault()); LocalDateTime转时间戳 1234LocalDateTime dateTime = LocalDateTime.now();dateTime.toInstant(ZoneOffset.ofHours(8)).toEpochMilli();dateTime.toInstant(ZoneOffset.of(&quot;+08:00&quot;)).toEpochMilli();dateTime.atZone(ZoneId.systemDefault()).toInstant().toEpochMilli(); 关于时区的计算也很简单，就是相差几个小时就加上多少秒 有些时区计算的时候，不妨自己加时间也一样，elasticsearch+logstash设置@timestamp时间是默认UTC Z的时间，和咱们差了8个小时 1LocalDateTime.parse(json.getString(&quot;@timestamp&quot;), DateTimeFormatter.ISO_DATE_TIME).plusHours(8L) 1.5 和Date互转123456789101112131415import java.time.Instant;import java.util.Date;public class Main { public static void main(String[] args) { Date dt = new Date(); System.out.println(\"Date: \" + dt); Instant in = dt.toInstant(); System.out.println(\"Instant: \" + in); Date dt2 = Date.from(in); System.out.println(\"Date: \" + dt2); }} Instant 和 LocalDate或LocalDateTime 就不赘述了… 代码来自 Java 日期时间传统互操作性 1.6 更好的理解和操作方式Date、Calendar的操作，例如设置月份，day of week 都有些让人迷惑，例如1月的定义是0，周一是0。1号好像也是0吧（我真没咋用过这东西，现用现百度… LocalDate感觉好多了。例如DayOfWeek是枚举类型。使用枚举就不会理解错了吧 很多日期和时间操作，无非就是加减时间和比较.使用‘加’的示例： 不用再去使用一个不熟悉的Calendar去操作了（Calendar提供的接口都是啥玩意，get，set的） 12Calendar cal = Calendar.getInstance();cal.set(Calendar.MONTH, cal.get(Calendar.MONTH) + 1) 2. 线程安全性比较LocalDate…系列是线程安全的额..每一个字段都用了final关键字了，都变不了… 所以进行操作后都是返回新的copy对象 至于说Date线程不安全，get,set的肯定在多线程的时候容易出现问题，不过set方法已经都@Deprecated废弃了。当然不是因为线程安全问题废弃的，是因为有了更好的替代 1Calendar.set(Calendar.DAY_OF_MONTH, int date) 不过感觉还是不如这个更清晰明了 1LocalDate.of(2019,1,12); 2.1 SimpleDateFormat的线程安全性 参考:深入理解Java：SimpleDateFormat安全的时间格式化 在一定负载情况下，SimpleDateFormat会出问题的。简单测试一下 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455package open.note;import java.text.SimpleDateFormat;import java.time.LocalDateTime;import java.time.format.DateTimeFormatter;import java.util.Date;import java.util.concurrent.CountDownLatch;import java.util.function.Consumer;public class UnSafeTest { private static String time = &quot;2019-01-11 11:11:11&quot;; private static long timestamp = 1547176271000L; private static LocalDateTime dateTime = LocalDateTime.of(2019,1,11,11,11,11); private static SimpleDateFormat dateFormat = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;); private static DateTimeFormatter formatter = DateTimeFormatter.ofPattern(&quot;yyyy-MM-dd HH:mm:ss&quot;); public static void main(String[] args) { dateFormatTest((obj)-&gt;{ try { Date date = dateFormat.parse(time); if (date.getTime() != timestamp){ System.out.println(date); } } catch (Exception e) { System.out.println(e.getMessage()); } }); System.out.println(&quot;---------------&quot;); dateFormatTest((obj)-&gt;{ try { LocalDateTime dateTime = LocalDateTime.parse(time,formatter); if (!dateTime.isEqual(UnSafeTest.dateTime)){ System.out.println(dateTime); } } catch (Exception e) { System.out.println(e.getMessage()); } }); } private static void dateFormatTest(Consumer runnable){ CountDownLatch countDownLatch = new CountDownLatch(1000); for (int i = 0; i &lt; 1000; i++) { new Thread(()-&gt;{ runnable.accept(null); countDownLatch.countDown(); }).start(); } try { countDownLatch.await(); } catch (InterruptedException e) { e.printStackTrace(); } }} 输出结果 1234567891011multiple pointsmultiple pointsempty StringSat Jan 11 11:11:11 CST 111Fri Jan 04 11:11:11 CST 2019For input string: &quot;&quot;Mon Dec 31 11:11:11 CST 2018Mon Dec 31 11:11:11 CST 2018For input string: &quot;&quot;Tue Jan 11 11:11:11 CST 42101--------------- 测试过程中，SimpleDateFormat 1000个线程里，有5次，时间解析错了，5次异常了（时间错了，比抛出异常还可怕）DateTimeFormatter只是对比参考一下,未出现异常（人家已经声明是线程安全了…）当然SimpleDateFormat线程不安全应该人尽皆知的，但依然有不安全的使用，但每次使用都new一个实例，当负载大的时候也不好。所以一个线程一个SimpleDateFormat实例应该可以的。 最后java8 对时间操作的类还有很多 到java.time包下去看看，以后总会用得到的地方。 Instant：时间戳Duration：持续时间，时间差LocalDate：只包含日期，比如：2016-10-20LocalTime：只包含时间，比如：23:12:10LocalDateTime：包含日期和时间，比如：2016-10-20 23:14:21Period：时间段ZoneOffset：时区偏移量，比如：+8:00ZonedDateTime：带时区的时间Clock：时钟，比如获取目前美国纽约的时间 更多的示例参考","link":"/2019-01/java8-time-date.html"},{"title":"kafka","text":"kafka，说说一些我使用的经验吧 项目中使用kafka，发现一个在外网无法连接kafka的问题，内网的搭建也是同事搞定的，所以就想自己搭建一次，体验一下，（kafka搭建在阿里的专有网络的ECS上） kafka的部署生产环境的咱们就不说了，只说开发环境或者本地吧，我是在自己电脑上装的，一开始是下载了安装包，后来发现使用docker才是王道！ 以下是我的 docker-compose.yml 配置 1234567891011121314151617version: '3'services: zookeeper: image: wurstmeister/zookeeper ports: - \"2181:2181\" kafka1: image: wurstmeister/kafka container_name: kakfa1 ports: - \"9092:9092\" environment: KAFKA_LISTENERS: PLAINTEXT://kafka1:9092# KAFKA_ADVERTISED_HOST_NAME: kafka1 KAFKA_ZOOKEEPER_CONNECT: zookeeper:2181 volumes: - /var/run/docker.sock:/var/run/docker.sock 不是docker安装的出的kafka性能更好，是很方便管理的 Kafka 常用命令平时调试12345678#$ip:$port 是kafka实例的ip和端口号，在低版本可能连的zookeeper的ip和端口# 给topic是$topic的发送消息bin/kafka-console-producer.sh --broker-list $ip:$port --topic $topic# 接收$topic的消息bin/kafka-console-consumer.sh --bootstrap-server $ip:$port --topic $topic#如果需要从头读取，加上参数 --from-beginningbin/kafka-console-consumer.sh --bootstrap-server $ip:$port --topic $topic --from-beginning 这几个命令，我主要用来 检查网络 测试，测试写的代码是否实现了相应的功能 ###检查维护 平时检查，可能需要知道，消息的订阅者在哪台服务器上消费的，有多少消息还没有被消费 12#查看订阅组groupId的消费情况bin/kafka-consumer-groups.sh --bootstrap-server ip:port --describe --group groupId 通过命令可以看到topic的分区id，当前的偏移量offset,LOG-END-OFFSET,LAG落后的数量，CONSUMER-ID，HOST，CLIENT-ID 设置主题的分区数1bin/kafka-topics.sh --zookeeper $ip:$port --alter --partitions $Num --topic $topic 这个命令应该在创建分区的时候就执行的，默认就1个分区，这样就导致了消费者也就1个！当消息很多的时候就容易出现消费落后的情况 经验之谈kafka使用的时候，一定要根据业务合理设置ACK,根据业务量以及消费情况，合理设置topic分区量，以及消息压缩和批量发送的数量。 日志落后上亿条没有被消费是什么情况呢？ 客服：用户反应咱们APP上的状态不准呀，好像有延时 有延时，查看消费情况吧，嚯，好家伙，有1亿多条消息没有被消费是什么情况！？消费者怎么只有一个实例！？ 好吧，这个topic是客服端自动创建的，没有设置分区数，默认就是一个！ 赶紧调整了下分区数，消费的情况是快了点，我根据每分钟消费的数量，以及增长的情况，预计3，4天后可以消费完！修复一个bug怎么能用那么久！毕竟消息也有时效性，没有消费的就不要了吧，我们换了新的topic解决！ 尽量不要使用默认的创建topic方式 spring kafka如果是平常的项目的话，建议使用spring kafka，而不是直接使用kafka的客户端。除了spring kafka开箱即用外，当topic修改分区数量的时候，spring kafka也能相应的增加消费者的数量。 使用spring kafka时，默认是自动提交偏移量的，如果代码异常，可以通过注解进行捕获统一处理。 spring boot的配置项里基本上可以把需要优化的东西都配置上，而不是在写一遍代码，然后再注入bean,在网上看到很多集成sprin kafka 写了好多代码… spring kafka 只是封装了kafka的客户端 分区 partition把kafka当作消息队列来用的话，那么消息应该是有顺序的，不能重复消费的。实际上kafka并不保证强顺序一致性。除非就使用了一个partition，当只有一个partition时就只有一个消费者，所以顺序是肯定一致的，当有多个partition时，消息会根据消息的key的hash值取余存到对应的partition中（如果没有key就轮询的保存）。 需要高吞吐的服务，肯定是要多个partition以及多个consumer来处理的，否则很容易出现我犯得消息积压的错。但多个消费者来消费时又需要考虑顺序的一致，这个可以通过key来下手，有业务关联的消息可以使用相同的key来解决。 参考文档： http://kafka.apachecn.org/ 一些kafka的特性如何保证消息不丢失Producer请求到broker上后，leader节点写人本地日志并同步到副本里，只要有一个副本存在就不会丢失。但在这个过程中，broker会根据ACKS的设置决定在什么时刻回复消息发送的结果，例如acks=0，就代表producer只管发消息，不确认是否同步成功，那么就不保证消息不会丢 持久化kafka 消息的存储和缓存是依赖文件系统的，而不是内存。这样可以避免JVM的GC，也能减少大量服务启动时缓存到内存的时间 因直接保存在硬盘，可以不用消费完就删除（如何避免重复消费，这个可以在consumer控制） 性能毕竟是直接写磁盘，那么io操作基本上是最消耗性能，尤其是对面向高吞吐量设计的系统。 kafka实现上是写pagecache的，消息的进入，保存，读取，都是不解码的，socket和pagecache之间可以直接转移数据，避免重复的复制数据，去掉了用户空间的缓冲。就是zero-copy零拷贝的技术。所以，pagecache 和 sendfile 的组合使用意味着，在一个kafka集群中，大多数 consumer 消费时，您将看不到磁盘上的读取活动，因为数据将完全由缓存提供。 除了io外，就是网络带宽，kafka还有端到端的批量压缩，一批消息压缩后发送到服务器，服务器也以压缩的格式写入，最终consumer在消费时解压 消费者的pull vs push如果是broker是push模式的话，那么broker就得控制何时push和传输速率，但broker是很难获取consumer的消费能力，尤其是consumer非常多的时候。当消息积累时，也很难抉择，如果一条一条push又难免浪费系统性能！pull的话可以根据偏移量offset来自行决定拉取多少来消费 pull模式也有一些缺点，就是不知道broker是否有数据，必须一直请求然后等待。为了避免kafka有在pull中加入了参数。 kafka的设计上的巧妙具体文档: http://kafka.apachecn.org/documentation.html#design 高性能参考：https://www.cnblogs.com/aspirant/p/11481332.html","link":"/2018-03/kafka-0.html"},{"title":"macOs 挂载能读写的NTFS硬盘","text":"转自：https://nicklinyi.gitee.io/blog/2018/04/macOS-ntfs.html 折腾来折腾去，真的想把硬盘格式化了，网上也有专门的软件，但没碰到太好用的，幸好不常用移动硬盘！ Mac本身是支持NTFS写入的，只是NTFS是微软开发，由于版权和技术细节原因，苹果不愿公开说自己支持NTFS写入，也是有自己以后可能不支持NTFS写入的考量。 方法一：1.在terminal下使用命令diskutil list查询要挂载的NTFS硬盘名称 123456789101112131415161718192021$ diskutil listUUID=7E84540E-D729-44B9-9AB8-2056C250DC5D none auto ro/dev/disk0 (internal, physical): #: TYPE NAME SIZE IDENTIFIER 0: GUID_partition_scheme *251.0 GB disk0 1: EFI EFI 209.7 MB disk0s1 2: Apple_APFS Container disk1 250.8 GB disk0s2/dev/disk1 (synthesized): #: TYPE NAME SIZE IDENTIFIER 0: APFS Container Scheme - +250.8 GB disk1 Physical Store disk0s2 1: APFS Volume Macintosh HD 76.4 GB disk1s1 2: APFS Volume Preboot 19.5 MB disk1s2 3: APFS Volume Recovery 509.8 MB disk1s3 4: APFS Volume VM 3.2 GB disk1s4/dev/disk2 (external, physical): #: TYPE NAME SIZE IDENTIFIER 0: GUID_partition_scheme *4.0 TB disk2 1: EFI EFI 209.7 MB disk2s1 2: Apple_HFS macOSbackup 1000.0 GB disk2s2 3: Microsoft Basic Data data 3.0 TB disk2s3 从输出的结果可以看到，最下面那个data即为我的名称。 2.在terminal下使用命令diskutil info /Volumes/data查询该硬盘的UUID值 12345678910111213141516171819202122232425262728$ diskutil info /Volumes/dataDevice Identifier: disk2s3Device Node: /dev/disk2s3Whole: NoPart of Whole: disk2Volume Name: dataMounted: YesMount Point: /Volumes/dataPartition Type: Microsoft Basic DataFile System Personality: NTFSType (Bundle): ntfsName (User Visible): Windows NT File System (NTFS)OS Can Be Installed: NoMedia Type: GenericProtocol: USBSMART Status: Not SupportedVolume UUID: C0F838DA-F857-9CC0-2CC1-9CE6F19CE668Disk / Partition UUID: 2E13FC4C-6FC4-469F-B8DE-FBBAA5F5907DDisk Size: 3.0 TB (3000273383424 Bytes) (exactly 5859908952 512-Byte-Units)Device Block Size: 512 BytesVolume Total Space: 3.0 TB (3000273379328 Bytes) (exactly 5859908944 512-Byte-Units)Volume Used Space: 16.1 GB (16052121600 Bytes) (exactly 31351800 512-Byte-Units) (0.5%)Volume Available Space: 3.0 TB (2984221257728 Bytes) (exactly 5828557144 512-Byte-Units) (99.5%)Allocation Block Size: 4096 BytesRead-Only Media: NoRead-Only Volume: YesDevice Location: ExternalRemovable Media: Fixed 输出结果中Volume UUID即为data的UUID值。 3.在/etc/fstab中添加如下一行 1UUID=C0F838DA-F857-9CC0-2CC1-9CE6F19CE668 none ntfs rw,auto,nobrowse 具体操作如下： 1$ sudo vim /etc/fstab 然后输入刚才那一行（UUID值根据自己电脑的情况更改），最后保存退出（wq）. 4.退出自己的移动硬盘，然后拔出移动硬盘，再重新插上移动硬盘。这时，在桌面上不再显示移动硬盘的图标，但我们打开terminal，进入/Volumes文件夹就能看到了。 123$ cd /Volumes$ lsMacintosh HD data macOSbackup 5.通过软链接建立桌面快捷方式 12$ mkdir -p ~/Desktop/data$ ln -s /Volumes/data ~/Desktop/data 在桌面上，我们就能看到其快捷方式了。 方法二.https://blog.plcent.com/archives/209目前暂未测试该方法，所以没有把详细过程记录下来。 ##补充说明方法一对于最新的系统macOS High Sierra是有效的。 ##参考资料https://techsviewer.com/write-ntfs-driver-macos-high-sierra/ https://blog.plcent.com/archives/209 aijiv提供的答案","link":"/2018-10/macos-ntfs-rw.html"},{"title":"spring boot security入门级使用","text":"之前用的最多的是shiro，简单好理解，文档多。spring security相对好像评论差一点，但既然决定使用spring全家桶，就都要体验体验，实际上，spring security用起来也挺简单的。 项目说明spring security 功能远不止页面的访问控制，在spring boot的示例使用security 也是通过注解控制访问方法的。在这里只演示页面的访问控制。项目中有3个页面，首页（/）、登录页(/login)任何人都可以访问，hello页模拟业务页，只能登录后访问。 项目搭建如果还没有搭建项目可以参考我写的 spring boot 项目搭建,如果已经搭建了，在pom.xml添加个依赖即可： 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-security&lt;/artifactId&gt;&lt;/dependency&gt; 项目配置的配置类security 可以直接通过注解来控制，这里直接用一个java类来配置。 1234567891011121314@Configuration@EnableWebSecuritypublic class WebSecurityConfig extends WebSecurityConfigurerAdapter { @Override protected void configure(HttpSecurity http) throws Exception { http .authorizeRequests() .antMatchers(\"/\").permitAll() //匹配 / 的访问任何人都可以访问，就是首页可以直接访问。 .anyRequest().authenticated() //任何访问需要有权限的访问 .and().formLogin().loginPage(\"/login\").permitAll() //登录的路径 .and().logout().permitAll(); //退出 默认路径 /logout }} security 可以在内存里直接设置一个用户用于最高的权限（具体权限看你的配置）。这个用户可以通过代码来写入或者通过配置文件，如果不写，会生成一个默认的user，密码随机。这里演示通过配置文件的。 123456789spring: security: user: #账户 name: admin #密码 password: 123 #角色 roles: USER 页面（页面代码copy的程序员DD-翟永超）创建一些页面，以供等会的测试 此处页面的目录是spring boot的默认目录，使用的页面模板为thymeleaf 首页在templates新建index.html,用于在不登录的情况下访问 12345678910111213&lt;!DOCTYPE html&gt;&lt;html xmlns=&quot;http://www.w3.org/1999/xhtml&quot; xmlns:th=&quot;http://www.thymeleaf.org&quot; xmlns:sec=&quot;http://www.thymeleaf.org/thymeleaf-extras-springsecurity3&quot;&gt;&lt;head&gt; &lt;title&gt;Hello World!&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;Hello world!&lt;/h1&gt;&lt;form th:action=&quot;@{/logout}&quot; method=&quot;post&quot;&gt; &lt;input type=&quot;submit&quot; value=&quot;注销&quot;/&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt; hello-模拟业务页在templates新建hello.html,用于在登录的情况下访问，非登录情况下不能访问 12345678910111213&lt;!DOCTYPE html&gt;&lt;html xmlns=&quot;http://www.w3.org/1999/xhtml&quot; xmlns:th=&quot;http://www.thymeleaf.org&quot; xmlns:sec=&quot;http://www.thymeleaf.org/thymeleaf-extras-springsecurity3&quot;&gt;&lt;head&gt; &lt;title&gt;Hello World!&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;Hello world!&lt;/h1&gt;&lt;form th:action=&quot;@{/logout}&quot; method=&quot;post&quot;&gt; &lt;input type=&quot;submit&quot; value=&quot;注销&quot;/&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt; login 登录页在templates新建login.html 1234567891011121314151617181920212223&lt;!DOCTYPE html&gt;&lt;html xmlns=&quot;http://www.w3.org/1999/xhtml&quot; xmlns:th=&quot;http://www.thymeleaf.org&quot; xmlns:sec=&quot;http://www.thymeleaf.org/thymeleaf-extras-springsecurity3&quot;&gt;&lt;head&gt; &lt;title&gt;Spring Security Example &lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;div th:if=&quot;${param.error}&quot;&gt; 用户名或密码错&lt;/div&gt;&lt;div th:if=&quot;${param.logout}&quot;&gt; 您已注销成功&lt;/div&gt;&lt;form th:action=&quot;@{/login}&quot; method=&quot;post&quot;&gt; &lt;div&gt;&lt;label&gt; 用户名 : &lt;input type=&quot;text&quot; name=&quot;username&quot;/&gt; &lt;/label&gt;&lt;/div&gt; &lt;div&gt;&lt;label&gt; 密 码 : &lt;input type=&quot;password&quot; name=&quot;password&quot;/&gt; &lt;/label&gt;&lt;/div&gt; &lt;div&gt;&lt;input type=&quot;submit&quot; value=&quot;登录&quot;/&gt;&lt;/div&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt; 测试打开网页，点点就可以了 代码：https://gitee.com/northersong/spring-cloud-learning/tree/master/security 本文档的代码大部分copy于 http://blog.didispace.com/springbootsecurity/ 作者翟永超 区别之处在项目使用spring boot2.0.0，JDK9。内存用户之间写在配置文件里。","link":"/2018-03/spring-boot-security-leve-0.html"},{"title":"spring boot security JWT登录（前后分离一）","text":"为开放在公网的接口添加权限验证，在项目中，我决定使用spring的全家桶。权限也交过security管理。但关于JWT登录的方式，并未在官网的文档中找到对应的讲解。所以就自己实现了一下。（JWT是 Json Web Token 的缩写） 开头一个登录&amp;权限系统，主要的无非2点: 一个登录的action 请求的过滤器，Filter，过滤那些无权限的访问 在细化点，结合shiro和security的实现 loadUserByUsername，通过用户名从存储里（数据库/内存）获取user，这个user包含密码，是否锁定，是否过期，具有哪些角色&amp;权限等 自定义过滤器：判断请求里用户的凭证（token/cookie/session）是否可用,或动态的改变权限，或在上下文里添加用户登录的证明。 有时候我们还需要添加一些缓存的东西，缓存用户，缓存token 一些配置，例如记住我功能，cookie的失效时间等… 使用spring 全家桶来实现一个JWT登录吧spring boot项目搭建，非常简单，如果使用的IDE是IDEA，在新建项目时选择这个然后勾选下要用的东西，例如security,web,mysql,Jpa,myBatis,可以在这个截图的下一步里通过勾选直接依赖的。如果没有IDEA也可以去spring官网,通过 https://start.spring.io/ 直接生成一个project。 项目的依赖 pom.xmlpom.xml 的部分代码，相对普通web项目多了spring-boot-starter-security依赖做权限管理。使用工具直接生成项目时，勾选security,Lombok,Web,Mysql,Jpa.我使用spring data jpa做的持久化，不使用数据库的或用mybatis，灵活选择 1234567891011121314151617181920212223242526272829303132333435&lt;!-- spring boot --&gt;&lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.0.0.RELEASE&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt;&lt;/parent&gt;&lt;dependencies&gt; &lt;!-- 操作数据库 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-jpa&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- web --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- 权限管理 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-security&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- 一个小插件，让代码不用写getter setter --&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;scope&gt;runtime&lt;/scope&gt;&lt;/dependency&gt;&lt;/dependencies&gt; 一 登录security简单使用时和shiro很像的。所以这里就只上代码和一些注释。 1234567891011121314151617181920212223242526@PostMapping(\"/lgoin\")public ServiceResponse&lt;String&gt; auth(String username, String password) { UsernamePasswordAuthenticationToken upToken = new UsernamePasswordAuthenticationToken(username, password); Authentication authentication; try { // 注意加个捕获异常。这里和shiro的逻辑差不多，当认证错误时，会直接抛出异常的（例如密码错误，抛出BadCredentialsException） authentication = authenticationManager.authenticate(upToken); } catch (AuthenticationException e) { // 在这里面没有具体的列举各种异常对应的状态。只是把他们的父类放到了这里 // 关于登录异常见下图 return ServiceResponse.fail(\"fail login : \" + e.getMessage()); } if (authentication.isAuthenticated()){ // 把登录成功的证明放到全文中（这句话说的有点别扭) // 如果后续没有授权需要的业务，完全可以不把注释打开。 //SecurityContextHolder.getContext().setAuthentication(authentication); // 生成token 保存到内存里，然后把这个token的字符串发给前端 return ServiceResponse.success(tokenStore.generateToken2Store((JWTUserDetail) authentication.getPrincipal())); } return ServiceResponse.fail(\"fail login\");} 一些登录授权时会抛出的异常，我直接看AuthenticationException的子类。 登录返回（ServiceResponse是对json返回的一个封装）： 12345678910111213141516//成功时{ \"success\": true, \"stateCode\": 1, \"data\": \"$2a$05$kOlZRMYUuYu0UmWM6fVnA.TbGcODevE8R9bRGTA/k5.s9hwp/YuEq\", \"stateDesc\": null, \"stateDetail\": null}// 失败时（密码错误的时候）{ \"success\": false, \"stateCode\": 0, \"data\": null, \"stateDesc\": \"fail login : Bad credentials\", \"stateDetail\": null} 二 token的保存代码在这里对上面的 tokenStore.generateToken2Store(user) 简单说明一下。作用就是用user的username 加点盐，然后md5生成个字符串，也就是所谓的token。用这个token作为key，user为value，放到一个map里。当然条件允许下可以把map换成redis。如果内存不够用，redis也没有。就把user序列化加密为token，或者每次从数据库读取…具体怎么实现看你自己的业务吧。别盲从 1234567891011121314151617181920212223242526272829303132333435363738394041@Componentpublic class TokenStore { // 返回前端的token就是加密的字符串。这个是加密时生成盐用到的。没错，这个我就是按了一遍键盘，凑合用吧 private final String saltStr = \"qwertyuiopasdfghjklzxcvbnm1234567890QWERTYUIOPASDFGHJKLZXCVBNM\"; // 懒得数我敲了多少位的盐了。。。 private final int length = saltStr.length(); private final Random random = new Random(); // 有条件的用个redis，没条件的我，就直接放内存里了。 private final Map&lt;String, JWTUserDetail&gt; store = new ConcurrentHashMap&lt;&gt;(); public String generateToken2Store(JWTUserDetail userDetails) { // 简单的加下密 String token = PasswordEncoderHelp.encode(createSalt(30) + userDetails.getUsername()); store(token, userDetails); return token; } public void store(String token, JWTUserDetail details) { store.put(token, details); } public JWTUserDetail get(String token) { return store.get(token); } // 退出登录时需要移除内存里的用户 public JWTUserDetail remove(String token) { return store.remove(token); } // 我也不知道该怎么评论我的代码...屎不... public String createSalt(int length) { StringBuilder sb = new StringBuilder(); for (int i = 0; i &lt; length; i++) { sb.append(saltStr.charAt(random.nextInt(this.length))); } return sb.toString(); }} 三 过滤器123456789101112131415161718192021222324252627282930313233343536// 过滤每次request请求。@Componentpublic class JwtAuthenticationTokenFilter extends OncePerRequestFilter { private final TokenStore tokenStore; @Autowired public JwtAuthenticationTokenFilter(TokenStore tokenStore) { this.tokenStore = tokenStore; } @Override protected void doFilterInternal(HttpServletRequest request, HttpServletResponse response, FilterChain filterChain) throws ServletException, IOException { //Constant.headToken 一个常量 String tokenHead = request.getHeader(Constant.headToken); if (tokenHead != null) { // 从tokenStore 中获取对应的user UserDetails userDetails = tokenStore.get(tokenHead); // user 不是null，说明之前肯定通过/login接口登录过了 // getAuthentication() == null 说明上下文里没有其他证明用户登录的信息，咱们可以放心的覆盖。如果不是null，也可以根据具体需要选择是否覆盖 if (userDetails != null &amp;&amp; SecurityContextHolder.getContext().getAuthentication() == null) { // new 一个用户登录的证明 UsernamePasswordAuthenticationToken authentication = new UsernamePasswordAuthenticationToken( userDetails, null, userDetails.getAuthorities()); authentication.setDetails(new WebAuthenticationDetailsSource().buildDetails( request)); // 把这个证明放到上下文里~~ SecurityContextHolder.getContext().setAuthentication(authentication); } } // 不管是否登录了，咱们都放行。权限等判断交给其他过滤器，咱们只是添加证明 filterChain.doFilter(request, response); }} 四 一些关于权限的配置个人感觉纯粹的java代码比xml好多了 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849@Configurationpublic class ApplicationSecurity extends WebSecurityConfigurerAdapter { // 上文写的拦截器 private final JwtAuthenticationTokenFilter filter; // 这个就是loadUserByUsername的接口实现 private final UserDetailsService userDetailsService; @Autowired public ApplicationSecurity(JwtAuthenticationTokenFilter filter, @Qualifier(\"JWTUserDetailsService\") UserDetailsService userDetailsService) { this.filter = filter; this.userDetailsService = userDetailsService; } // 重写一下。加个@Bean，使在其他地方可以使用这个authenticationManager,例如在登录时使用 @Override @Bean public AuthenticationManager authenticationManagerBean() throws Exception { return super.authenticationManagerBean(); } // 让spring使用自己实现的UserDetailsService，并添加一个密码的加密的方式 @Autowired public void configureGlobal(AuthenticationManagerBuilder auth) throws Exception { auth.userDetailsService(userDetailsService).passwordEncoder(PasswordEncoderHelp.getEncoder()); } @Override protected void configure(HttpSecurity http) throws Exception { http // 禁用csrf保护，咱们使用的JWT的登录方式 .csrf().disable() // 咱们就不使用session喽 .sessionManagement().sessionCreationPolicy(SessionCreationPolicy.STATELESS).and() .authorizeRequests() // 这个路径是登录用的，不需要权限，即可访问 .antMatchers(\"/auth/**\").permitAll() // 下面3个是swagger文档的请求路径，也是让随便访问的 .antMatchers(\"/swagger-**/**\").permitAll() .antMatchers(\"/webjars/**\").permitAll() .antMatchers(\"/v2/api-docs\").permitAll() // 让跨域请求能够通过 .antMatchers(HttpMethod.OPTIONS, \"/**\").permitAll() .anyRequest().authenticated(); //添加自定义的过滤器 http.addFilterBefore(filter, UsernamePasswordAuthenticationFilter.class); }} 一些不重要的代码 JWTUserDetailsService接口UserDetailsService的实现。通过用户名获取用户： 12345678910@Overridepublic UserDetails loadUserByUsername(String username) throws UsernameNotFoundException { User user = userRepository.findUserByUsername(username); if (user == null) { logger.debug(\"user is null\"); throw new UsernameNotFoundException(\"Username : {\" + username + \"} not found\"); } long expireTime = 1000 * 60; return new JWTUserDetail(System.currentTimeMillis() + expireTime, user);} JWTUserDetailUserDetails接口的实现，还集成了我的user实体类，部分代码 1234567891011121314151617181920212223242526272829303132333435363738@EqualsAndHashCode(callSuper = true)@ToString@Datapublic class JWTUserDetail extends User implements UserDetails { public JWTUserDetail(long expireTime, User user) { this.expireTime = expireTime; setEnabled(user.getEnabled()); setId(user.getId()); setUsername(user.getUsername()); setPassword(user.getPassword()); } // 失效时间~ 也就是token的失效时间。还有一种思路，例如使用redis时，可以直接设置成缓存失效时间 private long expireTime; // 没有角色的管理。 @Override public Collection&lt;? extends GrantedAuthority&gt; getAuthorities() { return null; } @Override public String getPassword() { return super.getPassword(); } @Override public String getUsername() { return super.getUsername(); } @Override public boolean isCredentialsNonExpired() { return expireTime &gt; System.currentTimeMillis(); }} PasswordEncoderHelp一个简单的md5加密。 结尾至此，基本上所有的登录部分写完了，为了测试，可以再加一个测试用的controller。 本项目代码：暂未上传…","link":"/2018-04/spring-boot-security-JWT-0.html"},{"title":"跟五笔一样逼格的输入法","text":"自然就是双拼了！ 其实就是蛋疼想折腾，五笔又不好学 不过要谨慎，用了双拼，就用不惯全拼，用全拼时就容易打错字。我见过同事用五笔的，他就不会用拼音打字。。。","link":"/2018-08/ipunt-method-0.html"},{"title":"spring boot 2.0 + java9 快速搭建","text":"spring boot 发展到现在已经好几年了，java9发布至今也半年了。今天spring boot2.0 版本发布。尽管已经用spring boot做了很多项目，但一直也没有总结个东西，现在就从头开始记录一下 快速搭建spring boot相比传统的ssh等项目第一个优势：能非常快速的搭建一个可以直接写业务代码的项目！ 2种方式，用IDEA的，不用IDEA的 1. 用IDEA的开发者新建一个project或新建一个module然后按照图中选择，当然你要选择适合自己的JDK版本，我用的是JDK9 Next，填写一下项目的信息 Next,开始选择依赖 最喜欢的就是这个功能，可以直接根据需求来选择依赖，例如你想用MyBatis,直接勾选MyBatis即可。需要注意我画圈的地方，那个是spring boot 版本 spring boot 2.0 必须是jdk8+，如果你用的是jdk7，就不行了。如果你用的是jdk9，那么就只能是spring boot2.0了， 2. 没有IDEA的spring boot 有个快速开始的网站，IDEA也是通过这个网站来实现快速搭建的：https://start.spring.io/ 如图，注意选择spring boot的版本。选择好依赖后，把生成的代码下载下来导入到IDE中就可以了。当然用记事本开发的可以无视上一句 3. 以上都没用的当然也有直接新建一个maven项目，不适用任何工具的，但要记得配置文件名称不要写错，有一个朋友就是手动创建的，发现配置不起作用，怎么也找不到原因，，最后给别人一看，发现配置文件名写错了。当然配置文件名称不是一成不变的，但要改的话最好先了解下spring boot的约定 目录结构 目录与普通的maven项目无异，开发调试时，启动*Application.java里的main方法即可。配置文件application.properties,如果配置的比较复杂，推荐使用yaml格式。 结语以上流程非常快的，再回想下以前新建一个SSM框架的项目的过程，各种copy。对比一下也会发现spring boot 无比简洁！ 最后贴上生成的 pom.xml12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.northern&lt;/groupId&gt; &lt;artifactId&gt;first&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;packaging&gt;jar&lt;/packaging&gt; &lt;name&gt;first&lt;/name&gt; &lt;description&gt;Demo project for Spring Boot&lt;/description&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.0.0.RELEASE&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt; &lt;/parent&gt; &lt;properties&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;project.reporting.outputEncoding&gt;UTF-8&lt;/project.reporting.outputEncoding&gt; &lt;java.version&gt;9&lt;/java.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt; &lt;scope&gt;runtime&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt;&lt;/project&gt;","link":"/2018-03/spring-boot-2.0-java9.html"},{"title":"因资源用尽导致服务宕机","text":"就是一场生产上的服务雪崩引起的问题。并且我们服务中没有熔断措施！(ps: 终于亲身经历了) 1. 事故的发生服务调用场景和发生的事件如下图所示，红色表示服务不可用. 服务A和服务B都是内部服务，服务C_*为不同运营商提供的服务，遵循一样的协议。某一天，突然发现所有服务A调用服务B的请求都被熔断了。去服务器上看下，发现服务B依然运行。日志不再打印，最近的日志都是调用服务C_3请求超时。尝试了下重启，2，3分钟后服务又处于不可用状态。 1.1 查找原因第一时间想到了发生了死锁，立刻使用jstack查看一下，（忘记截图保存资料了）。发现是RestTemplate里有线程处于wait状态，联想到爆出的服务C_3服务处于宕机状态,立刻想到了httpClient里配置的最大连接被占满，而且没有配置当连接数占满后的等待超时时间，导致其他请求处于一直等待状态！而正在使用的连接，因为请求服务C_3超时（当时配置了超时时间10s）….当然故障的主要原因不仅于此，还有重试机制！当请求失败后，会间隔5s后重试，所以服务B的不可用状态不仅是因为新的请求而阻塞，主要原因是大量的重试。 1.2 临时的解决方案 立刻清除掉所有关于服务C_3的重试任务，清除掉后，服务B恢复正常。 缩短请求超时时间。因为协议约定接口是异步通知的方式，所以超时时间不应过长 2. 应该做的调用外部的服务，我们是通过同一个RestTemplate实例做的，这是个错误 2.1 资源应该是隔离的就像船舱一样，底部的船舱都会分隔成写小舱室，每个小舱室都可以做到完全隔离，以此确保某个舱室漏水时保证整个船是安全的。同理，针对多个服务C_*，他们之间的资源应该是隔离的，都有不同的RestTemplate实例 2.2 快速的失败机制如果单个服务C_*宕机后，在人工未介入前，应该在一定时间内，再请求该服务应该是快速失败，不阻塞。 3. 总结其实这个教训主要来自于资源的滥用和当服务出现故障后没有熔断机制。 服务_c*属于外部服务，并没有按照spring cloud的开发方式去做，现在看来，哪怕不按照spring cloud的去做，也要参考一些它的机制。 防雪崩利器：熔断器 Hystrix 的原理与使用","link":"/2019-01/service-down-hystrix.html"},{"title":"服务器时间与数据库时间未同步产生的bug","text":"最近接了个做投票网站的活，每人每天可以投票3次。查数据时，突然发现有人在零点的时候投了几百张票！有人在搞事情呀！查了半天才发现服务器和数据库时间不一致，然后检查每人每天限制时，又分别查了两个地方！ 投票设计1. 数据库在vote表里，每投一次票，就插入一条数据 12#只是个伪代码，示意一下insert into vote(id,user_id,team_id,create_time) 2. 每天一个人限制三次插入前，先统计一下，这个人投票次数 12#就是查询下，当前时间的天，该用户投票数据的统计select count(0) from vote v where v.user_id = :userId and to_days(v.create_t) = to_days(now()) 被刷票了！查下数据，发现有个人短短几天内投了几百张票！看数据库记录还都是零点前的2分钟内。11:58-00:00 这个时间段。奇怪了，反复检查代码，认为不可能出错。然后…在服务器上执行下 12dateMon Jul 9 15:06:35 CST 2018 好像比我的电脑慢了2分钟，再在数据库执行下 1select NOW(); 一对比，服务器比数据库慢了2分钟！ 然后就明白了，数据库里的create_time是用代码new Date()的，是服务器时间，所以，记录是11:58分，实际上，已经过了0点了。那么这个时间段内执行的 12to_days(v.create_t) = to_days(now())#因为 create_t 一直都是0点以前的，而now()是0点以后。所以统计出的票数一直是0，所以他能一直投票！ 解决 代码层面上，插入时间使用数据库时间！ 把服务器和数据库时间同步一下。 最后我只是把服务器时间和网络时间同步了一下。执行的命令： 1ntpdate 0.cn.pool.ntp.org 参考：https://www.chenyudong.com/archives/linux-ntpdate-time-synchronize.html 以后一定要注意服务器时间和数据库时间的问题，其实不止这些！有些东西的判断标准必须统一！","link":"/2018-07/linux-db-no-sync-time-bug.html"},{"title":"IDEA 内存优化","text":"Don’t be a Scrooge and give your IDE some more memory不要做守财奴，给IDE多留点内存吧。 你的电脑内存都8G、16G里，但只给JVM 512M的内存，感觉不卡吗在某些时候。 mac 上 IDEA 内存优化方式： windows 上文件名应该是和这个一样的，路径就在软件安装的位置。 编辑这个文件： 终端的方式是比较快捷的： 123atom /Applications/IntelliJ\\ IDEA.app/Contents/bin/idea.vmoptions#如果你没有atom，那就vim好了vim /Applications/IntelliJ\\ IDEA.app/Contents/bin/idea.vmoptions 在之前我想着既然电脑内存都16G了，那么就多分配点吧，实际上不是的，毕竟GC的时间跟需要清理的内存有关 123-Xms2G-Xmx2G-XX:ReservedCodeCacheSize=2G 至于不同的内存能得到效果如何，大家参考：IntelliJ IDEA 内存优化最佳实践 在这里针对默认配置，内存调大，或者一些微调，进行比较，得到了各种图形，很是直观。引用其总结： 即使对 IntelliJ IDEA 内存进行微调，都可以大大提升 IDE 性能。当然，内存分配越多，执行效果就越好。但是，你也会发现， IDE 之外许多其他应用程序也需要消耗内存，所以，大家的目标应该是在提高性能和内存消耗之间找到一个平衡。笔者认为，在大多数情况下，把 Xmx 值设置在 2G 和 3G 之间是最佳的。如果你有更多的时间可以用 jstat 和 jvisualm 检查用不同的 JVM 设置如何影响性能和内存占用。","link":"/2018-03/idea-memory-better-0.html"}],"tags":[{"name":"macOs","slug":"macOs","link":"/tags/macOs/"},{"name":"键盘映射","slug":"键盘映射","link":"/tags/%E9%94%AE%E7%9B%98%E6%98%A0%E5%B0%84/"},{"name":"Karabiner-Elements","slug":"Karabiner-Elements","link":"/tags/Karabiner-Elements/"},{"name":"elasticsearch","slug":"elasticsearch","link":"/tags/elasticsearch/"},{"name":"spring","slug":"spring","link":"/tags/spring/"},{"name":"spring cloud","slug":"spring-cloud","link":"/tags/spring-cloud/"},{"name":"eureka","slug":"eureka","link":"/tags/eureka/"},{"name":"hexo","slug":"hexo","link":"/tags/hexo/"},{"name":"git 服务器","slug":"git-服务器","link":"/tags/git-%E6%9C%8D%E5%8A%A1%E5%99%A8/"},{"name":"vps","slug":"vps","link":"/tags/vps/"},{"name":"博客","slug":"博客","link":"/tags/%E5%8D%9A%E5%AE%A2/"},{"name":"java","slug":"java","link":"/tags/java/"},{"name":"spring boot","slug":"spring-boot","link":"/tags/spring-boot/"},{"name":"kafka","slug":"kafka","link":"/tags/kafka/"},{"name":"spring boot security","slug":"spring-boot-security","link":"/tags/spring-boot-security/"},{"name":"security","slug":"security","link":"/tags/security/"},{"name":"随笔","slug":"随笔","link":"/tags/%E9%9A%8F%E7%AC%94/"},{"name":"spring boot 2.0","slug":"spring-boot-2-0","link":"/tags/spring-boot-2-0/"},{"name":"java9","slug":"java9","link":"/tags/java9/"},{"name":"运维","slug":"运维","link":"/tags/%E8%BF%90%E7%BB%B4/"},{"name":"bug","slug":"bug","link":"/tags/bug/"},{"name":"Hystrix","slug":"Hystrix","link":"/tags/Hystrix/"},{"name":"IDEA","slug":"IDEA","link":"/tags/IDEA/"}],"categories":[{"name":"运维维护","slug":"运维维护","link":"/categories/%E8%BF%90%E7%BB%B4%E7%BB%B4%E6%8A%A4/"},{"name":"运维部署","slug":"运维部署","link":"/categories/%E8%BF%90%E7%BB%B4%E9%83%A8%E7%BD%B2/"},{"name":"java","slug":"java","link":"/categories/java/"},{"name":"spring boot","slug":"spring-boot","link":"/categories/spring-boot/"},{"name":"系统","slug":"系统","link":"/categories/%E7%B3%BB%E7%BB%9F/"},{"name":"bug笔记","slug":"bug笔记","link":"/categories/bug%E7%AC%94%E8%AE%B0/"},{"name":"开发工具","slug":"开发工具","link":"/categories/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/"}]}